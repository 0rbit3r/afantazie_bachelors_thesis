\chapter{Graph layout algorithms}

Graph layout algorithms (or GLAs for short) are a set of algorithms that accept graph-representing data as an input
and produce positions of individual nodes as an output.
Whether you want to gain insight into a set of data or just view it in a visually pleasing way you will need a GLA to do so.

In this work we are going to assume that GLAs produce 2-dimensional layout
but it's worth mentioning that the number of dimensions can be arbitrarily high.

\section{Force-directed layout}

The most common type of GLAs are force-directed layout algorithms (or FDL for short). It's what Obsidian uses
\footnote{We weren't able to find any specifics about the algorithm used in Obsidian.
But from the way its Graph view behaves it's safe to assume a variation of an FDL algorithm was used.}
and Gephi provides several variations of.
The main idea behind FDL algorithms is a simple one - nodes are attracted to each other when connected by an edge and repelled otherwise.

While elegant in concept and easy to implement, this approach is endlessly customizable.
One fact we found especially useful is the fact that it's incremental and can be run real-time.
This produces visually pleasing animations of the data and allows for user interaction (eg. dragging nodes around or changing parameters).

Thanks to this aspect a developer implementing an FDL algorithm has the ability to adjust strength of the forces,
add new ones or implement entirely new behvior and parameters to fit the specific use-case
- all by watching the animation run and inferring what behavior needs to be changed.

Basic version of FLA doesn't properly end and the it's up to the user to stop the program when the layout is satisfactory.

\xxx{talk about - customizability, performance, real-time animations...}
\xxx{the layout is not deterministic. (Chaos theory, butterfly effect etc.)}

These possitives are however balanced by its time complexity. The basic version of FDL has a time complexity of $O(n^2)$ per step
where $n$ is the number of nodes in the graph.

For stabilization time usualy n steps are considered sufficient with the whole formula for stabilized graph $O(n^3)$.
But in our case we will just like obsidian allow user interaction and animation.
Thus we are more interested in the time complexity per step.

\subsection{ForceAtlas}


\subsection{Fruchterman-Reingold}

\section{OpenOrd}

\xxx{TODO - add a table comparng the algorithms talked about}